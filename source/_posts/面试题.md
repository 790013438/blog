## 两个线程相加，一个计算1到一万，一计算一万到两万
* Runnable
    * 进程和线程有什么区别和联系
        * 进程是操作系统分配内存的基本单元
        * 线程是分配CPU的基本单元
    * 两个进程共享数据-共享内存
        * 管道
        * 套接字
    * 两个线程共享数据
        * 共享一个对象
        * 共享上下文
        * 用内部类共享外部类的数据
        * 管道流(PipedInputStream/PipedOutputStream)
    ```java
    public class App {

      //atom branch
        private static AtomicInteger sum = new AtomicInteger();
      //        private static int sum;

        static class AddThread implements Runnable {
            private int begin;
            private int end;

            public AddThread(int begin, int end) {
                this.begin = begin;
                this.end = end;
            }

            @Override
            public void run() {
                for (int i = begin; i <= end; ++i) {
                    sum += i;
                }
            }
        }

        public static void main (String[] args) {
            Thread t1 = new Thread(new AddThread(1, 10000));
            t1.start();
            Thread t2 = new Thread(new AddThread(10000, 20000));
            t2.start();
            try {
                t1.join();
                t2.join();
            } catch (Exception e) {
                e.printStackTrace();
            }
            System.out.println(sum);
        }
    }
    ```
    > 使用线程池
    ```java
    public class App {

        static class AddThread implements Runnable {

            private int start;
            private int end;

            public AddThread(int start, int end) {
                this.start = start;
                this.end = end;
            }

                @Override
            public void run() {
                for (int i = start; i <= end; ++i) {
                    sum += i;
                }
            }
        }

        private static AtomicInteger sum = new AtomicInteger();
        private static ExecutorService service = Executors.newFixedThreadPool(2);

        public static void main (String[] args) {
            service.execute(new AddThread(1, 10000));
            service.execute(new AddThread(10001, 20000));
            Service.shutdown();
            while (!service.isTerninated()) { }
            System.out.println(sum);
        }
    }
    ```
    * 使用Callable
    ```java
    public class App {

        class AddThread implements Callable<Integer> {

            private Integer sum = 0;
            private int begin;
            private int end;

            public AddThread(int begin, int end) {
                this.begin = begin;
                this.end = end;
            }

            @Override
            public void run() {
                for (int i = begin; i <= end; ++i) {
                    sum.addAndGet(i);
                }
                return sum;
            }
        }

        private static ExecutorService service = Executors.newFixedThreadPool(2);

        public static void main (String[] args) {
            Future<Integer> f1 = service.submit(new AddThread(1, 10000));
            Future<Integer> f2 = service.submit(new AddThread(1001, 20000));
            try {
                int num1 = f1.get();
                int num2 = f2.get();
                System.out.println(num1 + num2);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```
    * java7 fork join
        > 排序，没有相关性的东西
        > Collections.sort --> java7 之前 Double pivot quick sort, Java 7+ 后TimSort
        > JMM -- Java memory model
    ```java
    
    ```
